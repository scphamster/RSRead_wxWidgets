/////////////////////////////////////////////////////////////////////////////
// Name:        RSRead.cpp
// Purpose:
// Author:      scphamster
// Modified by:
// Created:     26/06/2022 20:13:11
// RCS-ID:
// Copyright:   scphamster
// Licence:
/////////////////////////////////////////////////////////////////////////////

// Generated by DialogBlocks (unregistered), 26/06/2022 20:13:11

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

#include "wx/textfile.h"
#include "MainPanel.h"
#include "SerPortConfDlg.h"
#include "RSRead.h"

IMPLEMENT_CLASS(MainFrame, wxFrame)

BEGIN_EVENT_TABLE(MainFrame, wxFrame)

EVT_MENU(wxID_CLOSE, MainFrame::OnCloseClick)
EVT_MENU(wxID_SAVEAS, MainFrame::OnSaveToFileClick)
EVT_MENU(ID_CONFIGURE_SERIAL, MainFrame::OnConfigureSerialClick)
EVT_MENU(ID_START_RCVER, MainFrame::OnStartRcverClick)
EVT_MENU(ID_CLOSE_SERIAL, MainFrame::OnCloseSerialClick)
MY_THR_EVT(wxEVT_THR_SERIAL_COMPLETED, MainFrame::OnThreadCompletion)
MY_THR_EVT(wxEVT_THR_SERIAL_UPDATE, MainFrame::OnThreadUpdate)

END_EVENT_TABLE()

MainFrame::MainFrame()
{
    Init();
}

MainFrame::MainFrame(wxWindow       *parent,
                     wxWindowID      id,
                     const wxString &caption,
                     const wxPoint  &pos,
                     const wxSize   &size,
                     long            style)
{
    Init();
    Create(parent, id, caption, pos, size, style);
}

bool
MainFrame::Create(wxWindow       *parent,
                  wxWindowID      id,
                  const wxString &caption,
                  const wxPoint  &pos,
                  const wxSize   &size,
                  long            style)
{
    ////@begin RSREAD_DB creation
    wxFrame::Create(parent, id, caption, pos, size, style);

    CreateControls();
    Centre();
    ////@end RSREAD_DB creation
    return true;
}

MainFrame::~MainFrame()
{
    wxCommandEvent dummy;
    OnCloseClick(dummy);
}

void
MainFrame::Init()
{
    statusbar                = NULL;
    serialConfigs.port.first = SerialConfigs::PORT_NOT_SELECTED;

    databridgeConfigs.reset();
}

void
MainFrame::CreateControls()
{
    wxMenuBar *menuBar             = new wxMenuBar;
    wxMenu    *file                = new wxMenu;
    wxMenu    *configureSerialMenu = new wxMenu;

    file->Append(wxID_CLOSE, _("Exit"), wxEmptyString, wxITEM_NORMAL);
    file->Append(wxID_SAVEAS, _("Save to file"), wxEmptyString, wxITEM_NORMAL);

    configureSerialMenu->Append(ID_CONFIGURE_SERIAL, _("Configure Serial"), wxEmptyString, wxITEM_NORMAL);
    configureSerialMenu->Append(ID_START_RCVER, _("Start receiving..."), wxEmptyString, wxITEM_NORMAL);
    configureSerialMenu->Append(ID_CLOSE_SERIAL, _("Stop serial"), wxEmptyString, wxITEM_NORMAL);

    menuBar->Append(file, _("File"));
    menuBar->Append(configureSerialMenu, _("Serial"));
    SetMenuBar(menuBar);

    panel =
      new MainPanel(this, ID_PANEL, wxDefaultPosition, wxDefaultSize, wxSUNKEN_BORDER | wxTAB_TRAVERSAL);
    panel->SetExtraStyle(wxWS_EX_VALIDATE_RECURSIVELY);
    panel->SetBackgroundColour(wxColour(0, 0, 0));

    statusbar = new wxStatusBar(this, ID_STATUSBAR, wxST_SIZEGRIP | wxNO_BORDER);
    statusbar->SetFieldsCount(2);
    this->SetStatusBar(statusbar);
}

bool
MainFrame::ShowToolTips()
{
    return true;
}

wxBitmap
MainFrame::GetBitmapResource(const wxString &name)
{
    // Bitmap retrieval
    ////@begin RSREAD_DB bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
    ////@end RSREAD_DB bitmap retrieval
}

wxIcon
MainFrame::GetIconResource(const wxString &name)
{
    // Icon retrieval
    ////@begin RSREAD_DB icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
    ////@end RSREAD_DB icon retrieval
}

void
MainFrame::OnCloseClick(wxCommandEvent &event)
{
    {
        wxCriticalSectionLocker enable(CS);

        if (serialTask != nullptr) {
            if (serialTask->Delete() != wxTHREAD_NO_ERROR) {
                wxLogError("unsuccessful thread deletion");
            }
        }
    }

    while (1) {
        {
            wxCriticalSectionLocker enable(CS);
            if (serialTask == nullptr)
                break;
        }

        wxThread::This()->Sleep(1);
    }
    Destroy();
}

void
MainFrame::OnConfigureSerialClick(wxCommandEvent &event)
{
    // SerPortConfDlg *window      = new SerPortConfDlg(&serialConfigs, this);
    SerPortConfDlg *window      = new SerPortConfDlg(databridgeConfigs, this);
    int             returnValue = window->ShowModal();
    window->Destroy();
}

inline void
MainFrame::OnStartRcverClick(wxCommandEvent &event)
{
    if (serialTask == nullptr) {
        DoStartThread();
    }
    else {
        wxMessageDialog(this, "Receiver already started!", "Warning: receiver started").ShowModal();
    }
}

void
MainFrame::OnCloseSerialClick(wxCommandEvent &event)
{
    if (serialTask != nullptr) {
        serialTask->StopSerial();
        serialTask->Delete();
    }
    else {
        wxMessageBox("Serial Port is not started yet", "Stop Serial Error");
    }
}

void
MainFrame::OnSaveToFileClick(wxCommandEvent &event)
{
    if (serialTask == nullptr)
        return;

    wxTextFile newfile("LastSession.txt");

    if (newfile.Exists()) {
        std::cout << "file exists\n";
        newfile.Open();
    }
    else {
        std::cout << "file does not exist\n";

        newfile.Create();
    }

    newfile.GoToLine(newfile.GetLineCount());

    newfile.AddLine(fromSerialToFile);
    fromSerialToFile.erase();

    if (newfile.Write())
        wxMessageDialog(this, "Success upon file write procedure", "Success").ShowModal();
    else
        wxMessageDialog(this, "File write unsuccessful", "Mishap").ShowModal();

    newfile.Close();
}

void
MainFrame::DoStartThread()
{
    serialTask = new SerialThread(this, databridgeConfigs, databridgeData);

    if (serialTask->Run() != wxTHREAD_NO_ERROR) {
        wxLogError("thread start is unsuccessful");

        delete serialTask;
        serialTask = nullptr;
    }
}

void
MainFrame::OnThreadUpdate(wxThreadEvent &)
{
    if (serialTask == nullptr)
        return;

    if (databridgeData.empty() == true) {
        return;
    }

    auto data_item = std::make_shared<data_element_t>();
    databridgeData.pop_front_wait(data_item);

    wxString rawOutput;
    {
        char        buffer[100];
        tm         *timeinfo  = new tm;
        std::time_t arvl_time = data_item->msg_arrival_time;

        localtime_s(timeinfo, &arvl_time);
        strftime(buffer, sizeof(buffer), "%d-%m-%Y %H:%M:%S", timeinfo);

        rawOutput.append("Data Arival Time: ");
        rawOutput.append(buffer);
        rawOutput.append("   Bytes in buffer: ");
        rawOutput.append(std::to_wstring(data_item->bytes_in_buffer));
        rawOutput.append("RawData: ");

        for (int i = 0; (i < data_item->bytes_in_buffer) && (i < sizeof(data_item->data)); i++) {
            rawOutput.append(std::to_wstring((data_item->data[i])));
            rawOutput.append(" ");
        }

        rawOutput.append("\n");
        delete timeinfo;
    }

    wxString asciioutput;
    asciioutput.append(data_item->data, data_item->bytes_in_buffer);

    panel->textPanelASCII->SetCurrentPos(panel->textPanelASCII->GetLength());
    panel->textPanelASCII->AddText(asciioutput);
    panel->textPanelASCII->ScrollToEnd();

    panel->textPanelRAW->SetCurrentPos(panel->textPanelRAW->GetLength());
    panel->textPanelRAW->AddText(rawOutput);
    panel->textPanelRAW->ScrollToEnd();
}

void
MainFrame::OnThreadCompletion(wxThreadEvent &)
{
    wxMessageOutputDebug().Printf("this is message from OnCompletion");
}

std::pair<int, wxString>
MainFrame::GetPortSellection()
{
    return serialConfigs.port;
}

std::pair<int, wxString>
MainFrame::GetBaudrateSellection()
{
    return serialConfigs.baudrate;
}
